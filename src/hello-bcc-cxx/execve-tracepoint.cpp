#include <fcntl.h>
#include <signal.h>
#include <unistd.h>

#include <iostream>

#include <bcc/bcc_common.h>
#include <bcc/BPF.h>

static auto s_running = true;

constexpr auto bpf_source = R"(
int trace_sys_enter_execve(void *ctx) {
    char comm[16];
    bpf_get_current_comm(&comm, sizeof(comm));
    bpf_trace_printk("execv: %s", comm);
    return 0;
}
)";

int main()
{
    // 初始化 BPF
    ebpf::BPF bpf;
    if (!bpf.init(bpf_source).ok()) {
        std::cerr << "Failed to initialize BPF" << std::endl;
        return 1;
    }

    // 附着到 trace_sys_enter_execve 函数的 tracepoint
    if (!bpf.attach_tracepoint("syscalls:sys_enter_execve", "trace_sys_enter_execve").ok()) {
        std::cerr << "Failed to attach tracepoint" << std::endl;
        return 1;
    }

    // 打开 trace_pipe
    auto trace_pipe_fd = open("/sys/kernel/debug/tracing/trace_pipe", O_RDONLY);
    if (trace_pipe_fd < 0) {
        fprintf(stderr, "Failed to open trace_pipe: %m\n");
        exit(EXIT_FAILURE);
    }

    // 设置信号处理函数
    signal(SIGTERM, [](int) { s_running = false; });

    // 读取 trace_pipe
    while (s_running) {
        char buf[4096];
        ssize_t n = read(trace_pipe_fd, buf, sizeof(buf));
        if (n < 0) {
            if (errno == EINTR) {
                continue;
            }

            fprintf(stderr, "Failed to read trace_pipe\n");
            exit(EXIT_FAILURE);
        }
        printf("%.*s", (int)n, buf);
    }

    // 关闭 trace_pipe
    close(trace_pipe_fd);

    return 0;
}