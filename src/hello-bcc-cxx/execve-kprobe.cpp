#include <fcntl.h>
#include <signal.h>
#include <unistd.h>

#include <iostream>

#include <bcc/bcc_common.h>
#include <bcc/BPF.h>

static auto s_running = true;

constexpr auto bpf_source = R"(
int do_sys_execve(struct pt_regs *ctx, void *filename, void *argv, void *envp) {
    char comm[16];
    bpf_get_current_comm(&comm, sizeof(comm));
    bpf_trace_printk("execve: %s", comm);
    return 0;
}
)";

int main()
{
    // 初始化 BPF
    ebpf::BPF bpf;
    if (!bpf.init(bpf_source).ok()) {
        std::cerr << "Failed to initialize BPF" << std::endl;
        return 1;
    }

    // 获取 execve 的 syscall 函数名
    auto const fnname = bpf.get_syscall_fnname("execve");

    // 附着到 do_sys_execve 函数的 kprobe
    if (!bpf.attach_kprobe(fnname, "do_sys_execve").ok()) {
        std::cerr << "Failed to attach kprobe" << std::endl;
        return 1;
    }

    // 打开 trace_pipe
    auto trace_pipe_fd = open("/sys/kernel/debug/tracing/trace_pipe", O_RDONLY);
    if (trace_pipe_fd < 0) {
        fprintf(stderr, "Failed to open trace_pipe: %m\n");
        exit(EXIT_FAILURE);
    }

    // 设置信号处理函数
    signal(SIGTERM, [](int) { s_running = false; });

    // 读取 trace_pipe
    while (s_running) {
        char buf[4096];
        ssize_t n = read(trace_pipe_fd, buf, sizeof(buf));
        if (n < 0) {
            if (errno == EINTR) {
                continue;
            }

            fprintf(stderr, "Failed to read trace_pipe\n");
            exit(EXIT_FAILURE);
        }
        printf("%.*s", (int)n, buf);
    }

    return 0;
}